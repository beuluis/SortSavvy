package de.luisbeu.sort_savvy.persistence

import com.google.gson.Gson
import com.google.gson.GsonBuilder
import de.luisbeu.sort_savvy.SortSavvy
import net.minecraft.util.WorldSavePath
import net.minecraft.util.math.Direction
import java.io.File
import java.io.FileReader
import java.io.FileWriter

data class SerializedWorldRegistryKey(val registryId: String, val valueId: String)

data class PositionalContext(val x: Int, val y: Int, val z: Int, val toScanDirection: Direction, val worldRegistryKey: SerializedWorldRegistryKey)

// Model data class to specify structure and make serialization easier
data class DataStateModel(
    var quantumInventoryReaderData: MutableMap<String, PositionalContext> = mutableMapOf(),
)

object PersistentManager {
    private val gson: Gson = GsonBuilder().setPrettyPrinting().create()
    // Not sure if the data directory is the best since it normally is dimension bases and for the overworld. But we write json anyway and not nbt, so I guess we are good.
    private val dataStateFile = File(SortSavvy.LifecycleGlobals.getMinecraftServer().getSavePath(WorldSavePath.ROOT).resolve("data/SortSavvy.json").toString())
    // Initialize with default. Gets maybe overridden if a file already exists
    private var dataState: DataStateModel = DataStateModel()

    fun load() {
        try {
            // Check if we already have a data file and if yes load it and deserialize it
            if (dataStateFile.exists()) {
                dataState = gson.fromJson(FileReader(dataStateFile), DataStateModel::class.java)
            }
        } catch (error: Exception) {
            SortSavvy.logger.error("Data could not be loaded: ${error.message}")
            throw error
        }
    }

    fun getQuantumInventoryReaderData(): Map<String, PositionalContext> {
        return dataState.quantumInventoryReaderData
    }

    fun deleteQuantumInventoryReaderData(key: String) {
        dataState.quantumInventoryReaderData.remove(key)

        // Instantly save to disk to not lose any data
        saveData()
    }

    fun addQuantumInventoryReaderData(key: String, positionalContext: PositionalContext) {
        dataState.quantumInventoryReaderData[key] = positionalContext

        // Instantly save to disk to not lose any data
        saveData()
    }

    fun modifyQuantumInventoryReaderData(key: String, modifier: (PositionalContext) -> PositionalContext) {
        // Get the current PositionalContext to pass it to a modifier method
        val currentPositionalContext = dataState.quantumInventoryReaderData[key] ?: run {
            val msg = "Could not modify quantum inventory reader data with id: $key"
            SortSavvy.logger.error(msg)
            throw Exception(msg)
        }

        // Pass it and get the updated version
        val updatedPositionalContext = modifier(currentPositionalContext)

        // Update it at class level
        dataState.quantumInventoryReaderData[key] = updatedPositionalContext

        // Instantly save to disk to not lose any data
        saveData()
    }

    fun renameQuantumInventoryReaderData(oldKey: String, newKey: String) {
        // Retrieve the old PositionalContext and remove the old key
        val positionalContext = dataState.quantumInventoryReaderData.remove(oldKey) ?: run {
            val msg = "Could not retrieve previous data to rename quantum inventory reader data with id: $oldKey"
            SortSavvy.logger.error(msg)
            throw Exception(msg)
        }

        positionalContext.let {
            // Add the old PositionalContext under the new key
            dataState.quantumInventoryReaderData[newKey] = it

            // Instantly save to disk to not lose any data
            saveData()
        }
    }

    fun saveData() {
        try {
            // Get the parent directory of the data file
            val parentDirectory = dataStateFile.parentFile

            // Create the parent directory if it doesn't exist
            if (!parentDirectory.exists()) {
                parentDirectory.mkdirs()
            }

            val jsonObject = gson.toJsonTree(dataState).asJsonObject

            // Add a comment as a JSON property
            jsonObject.addProperty("comment", "Please do not edit this file manually! Especially not when the game is running.")

            FileWriter(dataStateFile).use { writer ->
                gson.toJson(jsonObject, writer)
            }

            SortSavvy.logger.info("Data was saved")
        } catch (error: Exception) {
            SortSavvy.logger.error("Data could not be saved: ${error.message}")
            throw error
        }
    }
}