package de.luisbeu.sort_savvy.persistent

import com.google.gson.Gson
import com.google.gson.GsonBuilder
import de.luisbeu.sort_savvy.SortSavvy
import net.minecraft.util.WorldSavePath
import net.minecraft.util.math.Direction
import net.minecraft.util.registry.RegistryKey
import net.minecraft.world.World
import java.io.File
import java.io.FileReader
import java.io.FileWriter

data class PositionalContext(val x: Int, val y: Int, val z: Int, val toScanDirection: Direction, val worldRegistryKey: RegistryKey<World>)

// Model data class to specify structure and make serialization easier
data class DataStateModel(
    var quantumInventoryReaderData: MutableMap<String, PositionalContext> = mutableMapOf(),
)

class PersistentManager {
    private val gson: Gson = GsonBuilder().setPrettyPrinting().create()
    // Not sure if the data directory is the best since it normally is dimension bases and for the overworld. But we write json anyway and not nbt so i guess we are good.
    private val dataStateFile = File(SortSavvy.LifecycleGlobals.getMinecraftServer().getSavePath(WorldSavePath.ROOT).resolve("data/SortSavvy.json").toString())
    private var dataState: DataStateModel

    init {
        try {
            // Check if we already have a data file and if yes load it and deserialize it
            if (dataStateFile.exists()) {
                dataState = gson.fromJson(FileReader(dataStateFile), DataStateModel::class.java)
            } else {
                // If not previous data file is found we create a new one with the default values defined by the model.
                dataState = DataStateModel()
                saveData()
            }
        } catch (error: Exception) {
            SortSavvy.logger.error("Data could not be loaded: ${error.message}")
            throw error
        }
    }

    fun getQuantumInventoryReaderData(): Map<String, PositionalContext> {
        return dataState.quantumInventoryReaderData
    }

    fun deleteQuantumInventoryReaderData(key: String) {
        dataState.quantumInventoryReaderData.remove(key)

        // Instantly save to disk to not lose any data
        saveData()
    }

    fun addQuantumInventoryReaderData(key: String, positionalContext: PositionalContext) {
        dataState.quantumInventoryReaderData[key] = positionalContext

        // Instantly save to disk to not lose any data
        saveData()
    }

    fun modifyQuantumInventoryReaderData(key: String, modifier: (PositionalContext) -> PositionalContext) {
        // Get the current PositionalContext to pass it to a modifier method
        val currentPositionalContext = dataState.quantumInventoryReaderData[key] ?: run {
            SortSavvy.logger.error("Could not modify quantum inventory reader data with id: $key")
            throw Exception() // TODO: ex
        }

        // Pass it and get the updated version
        val updatedPositionalContext = modifier(currentPositionalContext)

        // Update it at class level
        dataState.quantumInventoryReaderData[key] = updatedPositionalContext

        // Instantly save to disk to not lose any data
        saveData()
    }

    fun renameQuantumInventoryReaderData(oldKey: String, newKey: String) {
        // Retrieve the old PositionalContext and remove the old key
        val positionalContext = dataState.quantumInventoryReaderData.remove(oldKey) ?: run {
            SortSavvy.logger.error("Could not retrieve previous data to rename quantum inventory reader data with id: $oldKey")
            throw Exception() // TODO: ex
        }

        positionalContext.let {
            // Add the old PositionalContext under the new key
            dataState.quantumInventoryReaderData[newKey] = it

            // Instantly save to disk to not lose any data
            saveData()
        }
    }

    fun saveData() {
        try {
            // Get the parent directory of the data file
            val parentDirectory = dataStateFile.parentFile

            // Create the parent directory if it doesn't exist
            if (!parentDirectory.exists()) {
                parentDirectory.mkdirs()
            }

            val jsonObject = gson.toJsonTree(dataState).asJsonObject

            // Add a comment as a JSON property
            jsonObject.addProperty("comment", "Please do not edit this file manually! Especially not when the game is running.")

            FileWriter(dataStateFile).use { writer ->
                gson.toJson(jsonObject, writer)
            }
        } catch (error: Exception) {
            SortSavvy.logger.error("Data could not be saved: ${error.message}")
            throw error
        }
    }
}